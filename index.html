<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PACES Faces</title>
    <style>
        /* CSS styles */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: #3498db;
            color: #fff;
            padding: 1rem;
            text-align: center;
        }

        main {
            flex: 1; /* Fill remaining space between header and footer */
            display: flex;
            flex-direction: column;
        }

        .zone-container {
            flex: 1; /* Fill remaining space in the main content area */
            display: flex;
            flex-direction: row;
            border-top: 1px solid #ccc; /* Optional: Add a border between zones 2 and 3 */
        }
        
        .zone-1 {
            height: 10%;
            background-color: #2ecc71; /* Change the background color for Zone 1 */
            display: flex;
            justify-content: space-around;
            align-items: center;
            /* Optional: Add additional styles for the navigation buttons */
        }
        
        /* Updated styles for the buttons container */
			.zone-1-buttons {
    		width: 80%;
    		display: flex;
    		justify-content: space-between;
		  }
		  
		  /* Updated styles for the buttons */
			button {
    		font-size: 2vw; /* Responsive font size based on viewport width */
    		padding: 1.5vw 2vw; /* Responsive padding based on viewport width */
    		border: none;
    		color: black; /* Text color set to black */
    		cursor: pointer;
    		background-image: linear-gradient(#e6f7ff, #ccc); /* Gradient background */
    		max-width: 20%; /* Set maximum button width to 20% of the parent element (zone 1) */
			}

		 	/* Set maximum font size for buttons to 20 pixels */
			@media (min-width: 1000px) {
    			button {
        			font-size: 20px;
    			}
			}

			/* Hover effect for buttons */
			button:hover {
    		background-image: linear-gradient(#b3e0ff, #b3b3b3); /* Lighter gradient on hover */
			}

        .zone-left {
            flex: 1; /* Occupy half of the zone-container (50%) */
            background-color: #f1f1f1; /* Optional: Add background color to differentiate zones */
            padding: 1rem;
        }

        .zone-right {
            flex: 1; /* Occupy half of the zone-container (50%) */
            background-color: #f9f9f9; /* Optional: Add background color to differentiate zones */
            padding: 1rem;
            display: flex;
            flex-direction: column;
    			align-items: center;
        }
        
        .output-box {
    			width: 100%;
    			max-width: 500px; /* Set a maximum width for the output box */
    			margin: 0 auto; /* Center the output box horizontally */
    			padding: 1rem;
    			border: 1px solid #ccc;
    			border-radius: 5px;
    			background-color: #fff;
    			font-size: 1.6rem;
    			color: black;
		 }

        footer {
            background-color: #3498db;
            color: #fff;
            text-align: center;
            padding: 1rem;
        }
        
        /* Flashcard styles */
        .flashcard {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px; /* Adjust as needed */
            max-height: 100%;
            overflow: auto;
        }
        
        /* Update to make questions larger and bolded */
        .question {
            font-size: 16px; /* Adjust the font size as needed */
            font-weight: bold;
        }

        /* Hide the answer initially */
        .answer {
            display: none;
            font-size: 20px;
            font-weight: normal;
        }
        
        /* Style for the overlay box */
    	 .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1;
    }

   	  .overlay-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        max-width: 80%;
    }

   	  .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
    }
    
    /* Styles for the drop-down menu */
			.dropdown-menu {
    		position: absolute;
    		top: 50%; /* Change this to 50% to vertically center the menu */
    		right: 1rem; /* Change this to set the menu position to the far right */
   		 transform: translateY(-50%); /* Vertically center the menu using translateY */
   		 display: inline-block;
    		margin-right: 10px;
	}

		/* Style the drop-down button */
		#dropdownBtn {
    		background: none;
    		border: none;
    		font-size: 24px;
    		cursor: pointer;
}

		/* Style the drop-down content (the options) */
		.dropdown-content {
    		display: none;
    		position: absolute;
    		top: 100%;
    		right: 0;
    		background-color: #f9f9f9;
    		min-width: 160px;
    		padding: 12px 16px;
    		z-index: 1;
    		border-radius: 5px;
    		box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

		/* Show the drop-down content when the drop-down button is hovered over */
		.dropdown-menu:hover .dropdown-content {
    		display: block;
}

/* Styles for dark mode */
body.dark-mode {
    background-color: #333;
    color: #fff;
}

body.dark-mode header {
    background-color: #222;
}

body.dark-mode .zone-container {
    border-top-color: #555;
}

body.dark-mode .zone-left {
    background-color: #444;
}

body.dark-mode .zone-right {
    background-color: #555;
}

body.dark-mode .zone-1 {
	background-color: #3f3e40;
}

body.dark-mode #dropdownBtn {
    color: #fff; /* Set the color to white in dark mode */
}

        /* Position the dropdown menu button in the top right corner of the header */
        header {
    background-color: #3498db;
    color: #fff;
    padding: 1rem;
    text-align: center;
    position: relative; /* Add this line to set the header position to relative */
}

        .dropdown-menu-button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
    
    	/* Set initial font size for the flashcard text (question and answer) */
.flashcard h2, .flashcard p {
    font-size: 4vw; /* Responsive font size based on viewport width */
}

/* Set maximum and minimum font size for the flashcard text */
@media (max-width: 600px) {
    .flashcard h2, .flashcard p {
        font-size: 16px; /* Minimum font size of 16 pixels */
    }
}

@media (min-width: 601px) and (max-width: 1000px) {
    /* Interpolate font size between 16px and 24px based on screen width */
    .flashcard h2, .flashcard p {
        font-size: calc(16px + 8 * ((100vw - 600px) / 400)); /* Gradient font size */
    }
}

@media (min-width: 1001px) {
    .flashcard h2, .flashcard p {
        font-size: 24px; /* Maximum font size of 24 pixels */
    }
}

    </style>
</head>
<body>
    <header>
    <h1>PACES Faces</h1>
    <div class="dropdown-menu">
        <button id="dropdownBtn">&#9776;</button>
        <div class="dropdown-content">
            <!-- Options in the drop-down menu -->
            <a href="#" id="darkModeOption">Dark Mode</a>
        </div>
    </div>
</header>

<main>
    <div class="zone-container">
        <div class="zone-left">
            <!-- Zone 2 content goes here (Flashcard) -->
				<div class="flashcard">
    				<!-- Flashcard content (question and answer) goes here -->
    				<div class="question">
        				<!-- The question will always be visible -->
        				<h2 class="question-text">Flashcard Question</h2>
    				</div>
    				<div class="answer">
        				<!-- The answer will be hidden initially -->
        				<h2 class="answer-text">Flashcard Answer</h2>
        				<!-- Correct placement of the keywordContainer element inside the .answer div -->
       				 <div id="keywordContainer"></div>
    				</div>
    				<!-- Timer div goes here -->
    				<div id="timer">Time Remaining: <span id="timeRemaining">10</span> seconds</div>
    				<div id="timeUpMessage" style="display: none;">Time's up! Marking answer as incorrect.</div>
				</div>

        </div>
        <div class="zone-right">
            <!-- Zone 3 content goes here -->
            <div class="output-box">
                <!-- Voice output box -->
                <h2></h2>
                <p id="voiceOutput"></p>
            </div>
                    <!-- New div to display the result -->
        <div class="output-box" id="resultContainer"></div>
        </div>
    </div>
    

</main>


    <div class="zone-1">
        <!-- Zone 1 content (buttons) goes here -->
        <div class="zone-1-buttons">
            <button id="moreInfoBtn">More info</button>
            <button id="previousBtn">Previous</button>
            <button id="flipBtn">Flip</button>
            <button id="nextBtn">Next</button>
            <button id="speakAnswerBtn">Speak answer</button>
    			<button id="markAnswerBtn" onclick="markAnswer()" disabled>Mark answer</button>
        </div>
        
    </div>
    <footer>
        <p>&copy; 2023 Master Medical</p>
    </footer>
    
    <div class="overlay">
    <div class="overlay-content">
        <span class="close-btn" onclick="closeOverlay()">&times;</span>
        <p id="overlayText"></p>
    </div>
</div>
    
<!-- JavaScript code -->
<script>
  const flashcard = document.querySelector('.flashcard');
  const moreInfoBtn = document.getElementById('moreInfoBtn');
  const previousBtn = document.getElementById('previousBtn');
  const flipBtn = document.getElementById('flipBtn');
  const nextBtn = document.getElementById('nextBtn');
  const speakAnswerBtn = document.getElementById('speakAnswerBtn');
  const voiceOutput = document.getElementById('voiceOutput');

  let flipped = false;
  let recognizing = false;
  let recognition;

  // Sample flashcard content (you can remove this since we'll fetch data from a JSON file)
  let flashcardData = [];

  // Function to shuffle the flashcardData array randomly
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  // Fetch the flashcard data from the JSON file on GitHub
  fetch('https://raw.githubusercontent.com/mastermedical/flash/main/flashcards.json')
    .then((response) => response.json())
    .then((data) => {
      flashcardData = data; // Store the fetched data in the flashcardData variable
      shuffleArray(flashcardData); // Shuffle the flashcardData array before displaying the flashcards
      currentFlashcardIndex = 0; // Reset the current flashcard index to the beginning
      updateFlashcard(); // Initial update of the flashcard content after fetching the data
    })
    .catch((error) => {
      console.error('Error fetching flashcard data:', error);
    });

  // Array to keep track of the flipped state for each flashcard
  let flippedState = new Array(flashcardData.length).fill(false);

  // Initialize the currentFlashcardIndex
  let currentFlashcardIndex = 0;

  // Function to update the flashcard content
  function updateFlashcard() {
    const { question, answer, keywords } = flashcardData[currentFlashcardIndex]; // Get the keywords
    const questionContainer = document.querySelector('.question');
    const answerContainer = document.querySelector('.answer');

    // Update the question text (remains always visible)
    questionContainer.innerHTML = `<h2>${question}</h2>`;

    // Update the answer text (initially hidden)
    answerContainer.innerHTML = `<h2>${answer}</h2>`;
    answerContainer.style.display = 'none';
    flipped = false;

    // Enable or disable the "Flip" button based on the flippedState for this flashcard
    flipBtn.disabled = flippedState[currentFlashcardIndex];

    // Update the font size of the voice output box to match the flashcard text
    const fontSize = window.getComputedStyle(questionContainer).getPropertyValue('font-size');
    voiceOutput.style.fontSize = fontSize;

    // Clear the voice output and result when moving to a new flashcard
    voiceOutput.textContent = '';
    const resultContainer = document.getElementById('resultContainer');
    resultContainer.textContent = '';

    // Disable the "Mark answer" button for the new flashcard
    const markAnswerBtn = document.getElementById('markAnswerBtn');
    markAnswerBtn.disabled = true;

    // Display the keywords for this flashcard (optional, you can customize how you want to show them)
    const keywordContainer = document.getElementById('keywordContainer');
    keywordContainer.textContent = `Keywords: ${keywords.join(', ')}`;
  }

  // Function to handle the "Flip" button
  function flipFlashcard() {
    if (!flipped && !flippedState[currentFlashcardIndex]) {
      const answerContainer = document.querySelector('.answer');
      answerContainer.style.display = 'block';
      flipped = true;
      flippedState[currentFlashcardIndex] = true;
      moreInfoBtn.disabled = false; // Enable "More info" button
      flipBtn.disabled = true; // Disable "Flip" button for this flashcard
      
      // Start the timer when the user flips the flashcard
      startTimer(); // Call the function to start the timer
    }
    // Stop the timer when the "Speak answer" button is pressed
      clearInterval(timerInterval);
  }

// Function to handle the "Next" button
function nextFlashcard() {

  if (currentFlashcardIndex < flashcardData.length - 1) {
    // Stop the ongoing recognition if it's active
    if (recognizing) {
      recognition.stop();
      recognizing = false;
    }
        // Start the timer when the user flips the flashcard
      clearInterval(timerInterval); // Reset the timer interval
      startTimer();
      
    currentFlashcardIndex++;
    flipped = false; // Reset flipped state when moving to the next flashcard
    updateFlashcard();
    moreInfoBtn.disabled = true; // Disable "More info" button until flipped again
    voiceOutput.textContent = ''; // Clear the voice output box
    // Reset the "Mark answer" button state when moving to a different flashcard
    answerDictated = false;
    document.getElementById('markAnswerBtn').disabled = true;
  }

}

// Function to handle the "Previous" button
function previousFlashcard() {
  if (currentFlashcardIndex > 0) {
    // Stop the ongoing recognition if it's active
    if (recognizing) {
      recognition.stop();
      recognizing = false;
    }
          
      // Start the timer when the user flips the flashcard
      clearInterval(timerInterval); // Reset the timer interval
      startTimer();
      
    currentFlashcardIndex--;
    flipped = false; // Reset flipped state when moving to the previous flashcard
    updateFlashcard();
    moreInfoBtn.disabled = true; // Disable "More info" button until flipped again
    voiceOutput.textContent = ''; // Clear the voice output box
    // Reset the "Mark answer" button state when moving to a different flashcard
    answerDictated = false;
    document.getElementById('markAnswerBtn').disabled = true;
  }

}

  // Function to handle the "More info" button and display the overlay box
  function showMoreInfo() {
    if (flipped) {
      // Get the moreInfo content from the current flashcard data
      const moreInfoContent = flashcardData[currentFlashcardIndex].moreInfo;
      const overlayText = document.getElementById('overlayText');
      overlayText.textContent = moreInfoContent;

      // Show the overlay box
      const overlay = document.querySelector('.overlay');
      overlay.style.display = 'block';
    }
  }

// Function to handle the "Speak answer" button
function toggleDictation() {
  if (!recognizing) {
    recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.lang = 'en-UK'; // Set language to English (you can change it to another language if needed)

    recognition.onstart = () => {
      recognizing = true;
      speakAnswerBtn.textContent = 'Stop dictation'; // Change button text to 'Stop dictation' during voice recognition
      // Stop the timer when the "Speak answer" button is pressed
      clearInterval(timerInterval);
    };

    recognition.onend = () => {
      recognizing = false;
      speakAnswerBtn.textContent = 'Speak answer'; // Change button text back to 'Speak answer' when voice recognition stops
      // Enable the "Mark answer" button if an answer has been dictated
      document.getElementById('markAnswerBtn').disabled = !answerDictated;
     
    };

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      voiceOutput.textContent = transcript; // Update the voice output text
      // Mark that an answer has been dictated
      answerDictated = true;

      // Enable or disable the "Mark answer" button based on voice recognition state
      const markAnswerBtn = document.getElementById('markAnswerBtn');
      markAnswerBtn.disabled = recognizing || voiceOutput.textContent.trim() === '';

      // Call markAnswer() when voice recognition receives a result
      markAnswer();
    };

    recognition.start();
  } else {
    recognition.stop();
    recognizing = false;
    speakAnswerBtn.textContent = 'Speak answer'; // Change button text back to 'Speak answer' when voice recognition stops
    // Enable the "Mark answer" button if an answer has been dictated
    document.getElementById('markAnswerBtn').disabled = !answerDictated;

    // Call markAnswer() if recognition stops without speech input
    if (answerDictated && voiceOutput.textContent.trim() === '') {
      markAnswer();
    }
  }
}

  // Function to update the voice output text
  function updateVoiceOutput(text) {
    voiceOutput.textContent = text;
  }

  // Function to close the overlay box when the close button (X) is clicked
  function closeOverlay() {
    const overlay = document.querySelector('.overlay');
    overlay.style.display = 'none';
  }
  
  // Add an event listener to the "Dark Mode" option in the drop-down menu
document.getElementById('darkModeOption').addEventListener('click', toggleDarkMode);

// Function to toggle dark mode
function toggleDarkMode() {
    const body = document.body;
    body.classList.toggle('dark-mode');
}

  // Attach event listeners to the buttons
  moreInfoBtn.addEventListener('click', showMoreInfo);
  flipBtn.addEventListener('click', flipFlashcard);
  nextBtn.addEventListener('click', nextFlashcard);
  previousBtn.addEventListener('click', previousFlashcard);

  // Add event listener for "Speak answer" button when implementing voice recognition
  speakAnswerBtn.addEventListener('click', toggleDictation);
  
      // Function to preprocess the answer
    function preprocessAnswer(answer) {
        return answer.trim().toLowerCase();
    }

    // Function to tokenize the answer
    function tokenizeAnswer(answer) {
        return answer.split(/\s+/); // Split on whitespace to get individual words
    }

    // Function to remove stop words from the answer
    function removeStopWords(tokens) {
        const stopWords = ['a', 'an', 'the', 'is', 'in', 'and', 'on']; // Add more as needed
        return tokens.filter(token => !stopWords.includes(token));
    }

    // Function to calculate Jaccard similarity between two sets
    function jaccardSimilarity(setA, setB) {
        const intersection = new Set([...setA].filter(token => setB.has(token)));
        const union = new Set([...setA, ...setB]);
        return intersection.size / union.size;
    }


  // Function to check if the dictated answer contains keywords from the flashcard answer
  function keywordMatching(dictatedAnswer, flashcardAnswer) {
    const preprocessedDictatedAnswer = preprocessAnswer(dictatedAnswer);
    const preprocessedFlashcardAnswer = preprocessAnswer(flashcardAnswer);

    const dictatedTokens = new Set(removeStopWords(tokenizeAnswer(preprocessedDictatedAnswer)));
    const flashcardTokens = new Set(removeStopWords(tokenizeAnswer(preprocessedFlashcardAnswer)));

    // Check if any of the flashcard tokens exist in the dictated tokens
    const hasMatchingKeywords = [...flashcardTokens].some(token => dictatedTokens.has(token));

    return hasMatchingKeywords;
  }

  // Function to handle the "Mark answer" button and provide feedback
  function markAnswer() {
    const dictatedAnswer = voiceOutput.textContent; // Assuming you already have the dictated answer
    const { answer, keywords } = flashcardData[currentFlashcardIndex]; // Get the answer and keywords

    // Convert the dictated answer and keywords to lowercase for case-insensitive matching
    const preprocessedDictatedAnswer = dictatedAnswer.trim().toLowerCase();
    const preprocessedKeywords = keywords.map(keyword => keyword.toLowerCase());

    // Check if the dictated answer contains any of the keywords
    const isAnswerCorrect = preprocessedKeywords.some(keyword => preprocessedDictatedAnswer.includes(keyword));

    let result;

    if (isAnswerCorrect) {
      // Mark the answer as correct
      result = "Correct answer!";
    } else {
      // Mark the answer as incorrect
      result = "Incorrect answer!";
    }

    // Show the result in the result container
    const resultContainer = document.getElementById('resultContainer');
    resultContainer.textContent = result;
  }


// Function for timer
let remainingTime = 10; // Initial time limit in seconds
let timerInterval;

function startTimer() {
  remainingTime = 10; // Reset the remaining time to the initial value
  updateTimerDisplay(); // Update the timer display with the initial value
  timerInterval = setInterval(updateTimer, 1000); // Start the timer interval
}

function updateTimerDisplay() {
  const timeRemainingElement = document.getElementById('timeRemaining');
  timeRemainingElement.textContent = remainingTime;
}

function updateTimer() {
  if (remainingTime > 0) {
    remainingTime--;
    updateTimerDisplay();
  } else {
    clearInterval(timerInterval); // Stop the timer interval when time runs out
    // Here, you can implement the logic to mark the answer as incorrect due to timeout.
    console.log("Time's up! Marking answer as incorrect.");
  }
}


</script>

    
    
</body>
</html>
